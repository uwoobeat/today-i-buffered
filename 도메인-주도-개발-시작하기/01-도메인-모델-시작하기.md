# Ch.1 - 도메인 모델 시작하기

## 1.1 도메인이란?

- 소프트웨어로 해결하고자 하는 문제 영역이 도메인이다.  
- 한 도메인은 여러 개의 하위 도메인으로 나뉠 수 있다.
- 모든 도메인을 직접 구축하지 않고, 외부 업체의 시스템을 사용할 수 있다.
- 가령 온라인으로 책을 판매한다면 상품, 구매, 주문, 결제 ... 등의 도메인이 필요하다.
    - 가령 결제의 경우 PG사를 거친다.

## 1.2 도메인 전문가와 개발자 간 지식 공유

- 각 도메인에는 도메인 전문가가 존재한다. (홍보 도메인, 배송 도메인, ...)
- 도메인 전문가는 개발자에게 자신들이 원하는 기능을 요구한다.
- 개발자는 요구사항을 분석하고 / 설계하고 / 코드를 작성하고 / 테스트하고 / 배포한다.
- 이때, 요구사항을 올바르게 이해하는 것이 아주 중요하다! 하지만 어떻게?
    - 개발자와 전문가가 면대면으로 소통하는 것이 제일 좋다.
- 개발자도 도메인 전문가만큼은 아니더라도 도메인 지식을 갖춰야 한다.


## 1.3 도메인 모델

- 도메인 모델은 도메인을 개념적으로 나타낸 것이다.
- 도메인 모델을 나타낼 때 다양한 표현 방식을 사용할 수 있다.
    - 클래스 다이어그램, 상태 다이어그램...
- 도메인 모델은 '도메인을 모델링하여 쉽게 이해하기 위한 방식'이므로 여기에 맞춰주기만 하면 된다.
- 동일한 대상이 각각의 하위 도메인에서는 다르게 해석될 수 있다.
    - 가령 카탈로그의 '상품'은 판매를 위한 정보 데이터지만, 배송의 '상품'은 실제 물리적 대상을 의미한다.
    - 따라서 하위 도메인마다 따로 모델을 만들어주자.

## 1.4 도메인 모델 패턴

- 마틴 파울러의 책에서는 애플리케이션 아키텍처를 다음 네 개의 레이어로 정의한다.
    - 표현(Presentation) 레이어
    - 응용(Application) 레이어
    - 도메인(Domain) 레이어
    - 인프라스트럭처(Infrastructure) 레이어
- 섹션 1.3에서 말했던 도메인 모델은 '도메인을 이해하기 위해 모델링하여 표현한 것'이라면, 도메인 모델 패턴은 '위의 도메인 레이어를 객체지향적으로 구현하는 패턴'이다. (같은 용어를 쓰지만 다른 개념이다)
- 도메인 레이어에서는 도메인의 핵심 규칙을 구현한다.
    - 가령 '배송 이전에만 주문 취소가 가능하다' 라는 규칙을 구현하려면...
    - `OrderState`가 `isShippingChangeable()`을 구현하도록 할 수도 있지만
    - `Order`가 `isShippingChangeable()`을 구현하도록 할 수도 있다.
    - 개인적으로는 후자를 선호한다. 검증에 대한 책임은 상태를 나타내는 열거형이 아닌 상태를 저장하는 엔티티에서 가져야 하는 책임이기 때문에...

### 1.5 도메인 모델 도출

요구사항을 도메인 객체의 내부 상태 조작으로 표현한다. 


### 1.6 엔티티와 밸류

도메인과 엔티티와 밸류의 관계를 정리해보자.

앞에서 우리는 도메인이란 '소프트웨어로 해결하고자 하는 문제 영역'이라고 정의했다. 하나의 도메인은 엔티티와 밸류로 구분될 수 있다.

엔티티란 데이터베이스의 엔티티와 비슷하다. 이를 적절히 객체로 매핑해와서, 객체처럼 다룰 수 있게 만든 것이다. 그렇기 때문에 엔티티의 가장 큰 특징은 식별자, 즉 PK를 가진다는 것이다. 이 식별자는 우리가 직접 정할 수도 있고 (송장번호처럼), UUID / Nano ID 같은 것을 사용할 수도 있고, 사용자가 입력한 값 중 유니크한 값(아이디, 이메일 주소)을 사용할 수도, 아니면 데이터베이스에 의존적인 AUTO_INCREMENT 같은 것을 사용할 수도 있다.

책에서 다루지는 않지만 이전에 김영한 선생님 강의에 나오는 내용인데, PK 값은 현실세계와 무관한 값으로 설정해야 한다. 그래야 현실세계의 정책 변화로 인한 변경을 없앨 수 있다. 예전에 주민번호 등을 PK로 두었는데 개인정보 정책 변경으로 PK를 바꿔야 했다... 라는 이야기를 들으면서 나도 모르게 식은땀을 흘렸던 기억이 있다.

밸류 타입은 JPA의 임베디드 타입과 상당히 유사하다. 책에서는 `shippingAddress1`, `shippingAddress2`, `shippingZipcode` 세 필드를 합쳐서 하나의 개념, 즉 `Address` 클래스로 추출해낸 것을 예시로 들었다. 

재밌는 것은 하나의 필드도 밸류 타입으로 설정할 수 있다는 것이다. 가끔 자료형도 같고 개념도 같은 경우가 있다. 만약 `totalPrice`와 `discountPrice`, `balance` (잔고) 필드가 있다고 하자. 세 필드는 일반적으로 `int` 자료형을 쓸 것이다. 하지만 이 세 필드는 개념적으로 '돈'이라는 것을 나타내므로, 각각을 `Money` 타입으로 표현하면 더 명료한 의미를 가질 것이다. 

더 명료하다고? 과연 그렇게 말할 수 있을까? 싶을 것이다. '명료하다' 의 기준은 뭐냐? 요구사항에 따라 달라진다. 모델링은 현실세계에서 필요없는 부분은 버리고 필요한 부분을 취한 것이다. 필요한 부분이란? 우리가 해결하고자 하는 문제에 따라 달라진다. 즉, 우리가 `Money` 타입을 만듦으로써 우리가 해결하고자 하는 문제를 더 잘 해결할 수 있다면 `Money` 타입을 만들어야 한다는 것이다. 

더더 중요한 사실! '더 잘 해결할 수 있다' 라는 말이란 뭘까? 보통은 현재의 요구사항을 잘 충족시키는 것을 생각한다. 하지만 거기서 그쳐서는 안된다. 앞으로 발생할 가능성이 높은 요구사항이 등장하더라도, 유연하게 대처할 수 있도록 확장성 있게 만드는 것이 '더 잘 해결할 수 있다' 라는 것에 해당한다. 그러면 또 질문. '앞으로 발생할 가능성이 높은 요구사항'은 예측이 불가능한데, 어떻게 알아야 하나요? 라고 물을 수 있다.

이 물음에 대한 대답이 앞 1장에서 말했던 '개발자도 도메인 전문가만큼은 아니더라도 도메인 지식을 갖춰야 한다' 라는 것이다. 자신의 프로덕트에 대해 오너십을 가지는 개발자는 프로덕트가 속한 도메인에 대해서도 깊이 있게 이해한다. 그렇게 되면, 앞으로 발생할 가능성이 높은 요구사항을 예측할 수 있게 된다. 이러한 '가능성 높은 요구사항'은 설계에 반영되고, 궁극적으로는 소프트웨어의 품질에도 영향을 준다. 오너십을 가지는 것이 이토록 중요한 것이다.

아무튼! 당장의 `Money` 타입을 추가해놓고 아무런 동작을 정의하지 않으면 의미가 없다. 여기서는 `add`와 `multiply` 를 추가했다. 아니 이 정도는 그냥 `int` 타입으로 해도 되지 않나? 라고 생각할 수도 있다. 하지만 `Money` 타입을 사용하게 되면 기존에는 `Order` 클래스에 존재하던 `calculateAmount` 메서드가 `Money` 클래스의 책임 하에 들어가므로, 관심사가 적절히 분리된다. 즉 `Money` 클래스에 `add`와 `multiply` 메서드를 추가함으로써, `Order` 클래스에서는 `Money` 클래스의 책임을 위임하는 것이다. 이렇게 하면 `Order` 클래스의 가독성이 향상된다.

밸류 타입을 쓰는 또 한 가지 이유는 불변(immutable)이기 때문이다. 불변이란? 객체의 상태를 변경할 수 없다는 것이다. 불변 객체는 상태 변경이 불가능하므로, 멀티 스레드 환경에서 안전하다. 또한 불변 객체는 값이 같으면 동일한 객체라는 것을 보장한다. 이는 `equals` 메서드를 오버라이드할 때 유용하게 사용할 수 있다. 

특히 돈 같은 걸 다룰 때 일관성이란 상당히 중요하다. 가령 수량 속성과 가격 속성을 곱해서 전체 지불 금액 속성을 업데이트하는 메서드가 있다고 할 때, setter를 허용하여 가격을 마이너스로 바꿔버린다면? 판매자가 오히려 돈을 줘야 하는 상황이 만들어진다. 즉 우리는 수량 * 가격 = 지불 금액이라는 도메인 규칙을 만들었는데, 그 규칙이 깨지는 것이다. 책에서는 참조 투명성을 이야기하고 있고 이걸 설명하려면 함수형 프로그래밍에 이것저것 더 알아야 하므로 여기서는 생략한다.

마지막으로... 밸류 타입 간 비교 시 모든 속성을 비교한다. 식별자만을 비교하는 엔티티와는 다르다.

