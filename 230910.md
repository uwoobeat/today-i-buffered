## 이전 글 요약

이전 글에서 소개해드린 내용을 요약하자면 아래와 같습니다.

- 운영하고 있는 서비스가 확장됨에 따라, 다양한 유형의 유저가 등장하게 됨. 기존 레거시에서는 모든 서비스에서 공유하는 데이터를 가지고 있는 유저 클래스와, 이를 상속하는 각각의 서브타입 클래스 (e.g. `Parent`, `Teacher`, `Agent`) 를 만든 뒤, 이를 JPA 상속 관계 매핑의 조인 테이블 전략을 사용하여 해결했음.
- 여러 개의 서비스에서 같은 테이블을 같은 도메인 코드로 매핑해오므로, 도메인 코드의 중복이 발생함. 이를 해결하기 위해 추후 멀티 모듈 구조를 도입하기로 함. 인증 기능의 경우 모든 서비스에서 중복되기 때문에, 통합 인증 모듈로 분리할 수 있도록 개발해야 함.
- 따라서 인증 모듈 개발 시 최우선적으로 고려해야할 내용은 ‘다양한 유저 타입을 처리할 수 있는가?’임. 이때, ‘새로운 유저 타입의 추가 혹은 삭제’에도 유연하게 처리할 수 있어야 함.
- 기존 인증 기능은 유저의 서브타입 엔티티로 한번에 조회해오지 않고, 유저 한번, 서브타입 유저 한번 총 2회의 조회가 발생하기 때문에 성능 상 좋지 않음. 한번에 조회해오기 위해 모든 서브타입 유저의 레포지터리 빈을 주입받고, 이를 `switch` 문을 사용하여 해결해야 함.
- 하지만 `switch` 문은 OCP를 위반하기 쉽기 때문에 ‘새로운 유저 타입의 추가 혹은 삭제’에 유연하게 대처하기 어려움. 이를 해결하기 위해서는 서브타입 유저의 레포지터리를 동적으로 결정할 수 있어야 함. 그리고 실제 서브타입 유저에 대한 조회 쿼리는 레포지터리 빈 결정 시점이 아닌, 필요한 시점에 호출될 수 있어야 함 (이유는 후술).

## 어떻게 만들 것인가?

간단하게 생각해본 플로우는 이렇습니다.

1. 먼저 JWT 페이로드의 `role` 클레임을 기반으로 `UserRole` 열거형의 값을 결정합니다.
2. `UserRole` 열거형의 `domainClass` 프로퍼티를 기반으로 해당 열거형 값에 해당하는 도메인 클래스를 얻습니다.
3. 해당 도메인 클래스를 기반으로 레포지터리 빈을 찾습니다.
4. 해당 레포지터리 빈이 가지고 있는 메서드 목록 중에서, 우리가 원하는 메서드를 찾습니다.
5. 우리가 원하는 메서드를 기존 레포지터리 쿼리 메서드를 호출할 수 있도록 리턴값으로 넘겨줍니다.

가장 먼저 생각난 것은 예전에 작성했던 [‘@CreationTimestamp는 어떻게 작동할까’](https://uwoobeat.vercel.app/how-generated-properties-work) 에서 다뤘던 내용이었습니다. 해당 글에서는 DB에 해당 엔티티가 INSERT 되는 시점을 자동으로 생성해서 저장해주는 `@CreationTimestamp` 의 작동원리에 대해서 설명하고 있습니다. (참고로 관련 클래스들은 Spring 6.0부터는 `deprecated` 되었으니, 이점 참고하여 읽어주시면 되겠습니다.)

여기에 대해서도 간단하게 짚고 넘어가겠습니다.

- 먼저 해당 어노테이션을 들여다보면 내부적으로 `Map<Class<?>, ValueGenerator<?>> generators` 필드를 가지고 있습니다. 해당 맵은 static final로 선언되어, `initialize()` 를 통해 자바에 존재하는 시간 관련 클래스에 대하여 어떤 방식으로 ‘현재 시간’을 넣을지를 결정합니다. `generators` 에 들어갈 수 있는 값의 예시입니다.
    
    ```java
    generators.put(
    	LocalDateTime.class,
    	(session, owner) -> LocalDateTime.now()
    );
    ```
    
- 여기서 `ValueGenerator` 는 제네릭 타입을 가지는 함수형 인터페이스인 `supplier` 로, 실제로 `get` 이 호출되는 시점까지 `LocalDateTime.now()` 의 실행을 지연시켜, 실제로 INSERT가 이루어지는 시점에 값이 생성되도록 합니다.

저희에게 필요한 구현 역시 비슷합니다.

- 서브타입의 도메인 클래스를 목록으로 찾아온다.
- 해당 목록을 기반으로, (도메인 클래스, 레포지터리 빈) 쌍의 Map을 초기화한다.
- 해당 클래스에 대해 도메인 클래스를 파라미터로 넘겨주는 `get` 메서드를 호출하면, 레포지터리 빈의 쿼리 메서드에 해당하는 람다식을 넘겨준다.
- 호출하는 쪽에서는 쿼리 메서드의 람다식을 실행하여, 실제 실행되는 시점에 조회 쿼리를 발생시킨다.

## 유저의 자식 클래스 목록 스캔하기

### 선택 가능한 옵션

먼저 가장 중요한 점이 있습니다. 바로 유저의 자식 클래스 목록을 가져오는 부분입니다.

이와 관련해서 검색해보면 다양한 자료들이 나와있습니다. 

[How do you find all subclasses of a given class in Java?](https://stackoverflow.com/questions/492184/how-do-you-find-all-subclasses-of-a-given-class-in-java)

해당 글에서 제시된 방법은 다음과 같습니다.

1. 스프링 프레임워크의 `ClassPathScanningCandidateComponentProvider` 사용
    
    → 해당 유틸리티는 스프링 빈으로 관리되는 경우에만 가능합니다. 도메인 객체의 경우 스프링에 의해 관리되지 않기 때문에, 적용할 수 없습니다.
    
2. `Reflections` 라이브러리의 `getSubTypesOf(SomeType.class)` 사용
    
    → 해당 라이브러리의 경우 현재 개발이 중단된 상태입니다. 마지막 릴리즈가 2021년이니 뭐… 관리되지 않는 오픈소스 라이브러리는 신뢰하기 어렵기 때문에 프로덕션 환경에 적용하기엔 어렵다고 판단했습니다. 그리고 별도 라이브러리를 깔아야 한다는 게 별로 마음에 들지는 않았습니다. 최대한 빌트인 리플렉션 기능이나 스프링에서 제공되는 기능으로 처리하고 싶었습니다.
    
3. `ClassGraph` 라이브러리 사용
    
    → 꽤 다양한 기능을 지원하긴 하지만 저희에게 필요한 기능은 하나 뿐이고, 이를 위해 사전에 세팅해야 하는 부분도 살짝 번거로워보입니다. 또 2번과 마찬가지로 별도 의존성을 추가해야 하기 때문에…
    

### 굳이 서브타입을 스캔해야 하나?

그래도 `Reflections` 가 가장 사용하기 편해보였기 때문에 울며 겨자먹기로 사용하려는 찰나… 불현듯 그런 생각이 떠올랐습니다.

***“굳이 상속구조를 이용해야 하나? 유저를 식별할 수 있는 다른 방법이 있지 않을까?”***

그렇다면 유저와 서브타입 유저 클래스에만 있는 ‘무언가’가 있을 겁니다. 생각해보면 하나가 있습니다. 

바로 `@DiscriminatorValue` 어노테이션입니다. 이 어노테이션은 상속 관계 매핑에서 조인 테이블 전략 사용시, `DTYPE` 칼럼에 넣을 값을 지정하는데 사용됩니다. 따라서, 해당 어노테이션이 달린 클래스 목록를 가져오면, 이것이 곧 `User` 의 서브타입 클래스 목록이 됩니다.

### 어노테이션으로 클래스 스캔하기

어노테이션 기반으로 클래스를 스캔하는 것은 꽤 간단합니다. 스프링 프레임워크에서 제공하는 유틸리티인 `AnnotatedTypeScanner` 를 사용하면 됩니다.

이제 본격적으로 코드를 짜봅시다. 

먼저우리가 만들 클래스의 이름을 `UserProviderFactory` 라고 합시다. 그리고, 클래스 내부에서 사용할 `AnnotatedTypeScanner` 를 선언해줍시다. 이 필드의 이름은 `userSubTypeScanner` 입니다.

```java
public class UserProviderFactory {
	private final AnnotatedTypeScanner userSubTypeScanner;

	public UserProviderFactory() {
		this.userSubTypeScanner = new AnnotatedTypeScanner(DiscriminatorValue.class);
	}
}
```

`AnnotatedTypeScanner.findTypes` 를 사용하면 해당 어노테이션이 달린 클래스 목록을 `Set` 으로 반환해옵니다. 하지만, 이 결과를 그대로 사용해서는 안됩니다. 그 이유는 `@DiscriminatorValue` , 즉 조인 테이블 전략을 사용하는 클래스가 지금은 `User.class` 와 그 서브타입밖에 없지만, 추후 요구사항에 따라 추가될 수도 있기 때문입니다. 따라서, 해당 어노테이션을 가진 클래스가 `User.class` 의 서브타입인지 확인하는 과정을 거쳐야 합니다. 

특정 클래스가 `User.class` 의 서브클래스인지 확인하려면 어떻게 할까요? `Class.isAssignableFrom()` 을 사용합니다. 해당 메서드는 인자로 넘어온 클래스 / 인터페이스가 이 메서드를 가진 클래스 / 인터페이스를 상속했거나 구현했는지를 검사합니다.

위 내용을 모두 고려해서, 유저의 서브타입을 스캔하는 메서드를 구현하면 다음과 같습니다.

```java
private Set<Class<? extends User>> getUserSubTypes() {
    return userSubTypeScanner.findTypes("com.package.artifact.domain")
            .stream()
            .filter(User.class::isAssignableFrom)
            .filter(not(User.class::equals)) // 1
            .map(clazz -> (Class<? extends User>) clazz) // 2
            .collect(Collectors.toSet());
}
```

추가로 1) `User.class` 자기 자신이 아닌지 검증하는 과정, 2) 클래스 와일드타입의 상한 경계를 `User` 로 설정해주는 과정을 추가했습니다. 또한, `collect` 가 아니라 스트림으로 반환해도 되지만, 본 클래스를 주입받는 곳에서 유저의 서브타입 셋을 필요로 하는 경우가 존재할 것 같아 스트림이 아닌 `Set` 으로 `collect` 해준 뒤 반환하도록 했습니다. 물론 해당 상황에서는 접근 제어자를 `private` 로 지정해야겠지만, 일단은 내부에서만 사용하므로, `private` 로 선언했습니다.

## 동적으로 레포지터리 빈을 결정하기

### 전략 패턴?

요구사항 중 하나는 `switch` 문을 사용하지 않고 유연하게 처리하는 것입니다. 이때, ‘전략 패턴’을 적용하는 것을 고려할 수 있습니다. 디자인 패턴 이야기가 나와서 조금 어렵게 느껴지실 수 있겠습니다만, 사실은 그렇게 어려운 개념이 아닙니다. ‘이전 글 요약’ 섹션에서 했던 말을 다시 인용하겠습니다.


> 하지만 `switch` 문은 OCP를 위반하기 쉽기 때문에 ‘새로운 유저 타입의 추가 혹은 삭제’에 유연하게 대처하기 어려움. 이를 해결하기 위해서는 서브타입 유저의 레포지터리를 동적으로 결정할 수 있어야 함.

사실 지난 글부터 주구장창 말하는 것 중 하나가 ‘동적으로 뭔가를 결정해야 합니다!’ 입니다. 러프하게 말하면, ‘동적으로 뭔가를 결정한다’ == ‘전략 패턴’입니다. 위에서 `@CreationTimestamp` 에서 내부적으로 (클래스 타입, 람다식) 쌍의 맵을 가지고 있다가, `get(특정 클래스 타입)` 을 호출하면 람다식을 리턴한다고 했잖아요? 이때 `get` 으로 넘겨주는 클래스 타입에 따라 반환되는 객체가 달라지니, 이 역시 전략 패턴에 해당합니다.

전략 패턴을 이미 알고 있는 분들은 아마 이렇게 생각하실 수도 있겠습니다.

- 전략에 해당하는 `Strategy` 인터페이스가 존재하고, 클라이언트에서는 이 전략에 의존한다
- 각 전략에 대한 구현체가 존재하고, 클라이언트에 해당 전략 구현체를 설정해줄 수 있다
- 클라이언트에서 해당 전략 구현체의 메서드를 호출하여 동적으로 다른 알고리즘을 실행할 수 있다

### 

## 지연 평가를 위한 람다식 그리고 리플렉션

지연 평가 해야하는 이유 = 트랜잭션 안에서 조회하기 위해서

## 유저 정보 수정이 안된다는데요?

`LazyBeanInitialization`

## 같은 트랜잭션에서 조회되도록 `UserUtils`로 이전하기

## 다른 쿼리 메서드도 다룰 수 있도록 리팩토링

이제는 exists 쿼리…

## 마무리