# 알잘딱한 테스트 만들기
## 문제
### 개요
서비스 레이어에서 너무 많은 스터빙이 발생한다. 도메인 목 객체의 동작, 레포지터리와 매퍼, 그리고 다른 서비스 컴포넌트의 동작을 모두 모킹해주었고 모킹된 메서드가 올바르게 호출되었는지 `verify`를 통해 호출 횟수를 검증했다.

하지만 큰 문제가 있었다. 회사에서 테스트 코드를 작성하면서 리팩토링할 때마다 테스트 코드가 완전히 깨져버려서 급한 피쳐를 개발해야 하는 경우 컴파일 에러 때문에 해당 테스트를 제외한 상태로 배포해야 하는 경우도 생겼었다.

이를 수정하기 위해서 기능 개발보다 더 많은 시간을 쏟아야 했고 전반적인 생산성 저하로 이어졌다.

아래는 그냥 찾아본 것들 두서없이 나열해봤다.

- 우리 테스트는 레이어 간 종속성을 전부 끊어내기 위해 모든 의존성을 모킹하고 있어 문제가 발생한다.
- 향로님의 글에서 '레포지터리 코드만 호출하는' 쿼리 모듈의 경우 레포지터리를 모킹 처리하는 것은 좋지 않다 라는 부분이 존재한다.
- 아니, 레포지터리 메서드는 이미 레포지터리 테스트에서 검증했는데 스터빙하는게 맞지 않나? 싶을 수도 있다.
- 유닛 테스트와 통합 테스트를 구별해야 한다. '레포지터리 메서드'만 호출하는 서비스 코드의 경우, 유닛 테스트를 작성할 필요가 없다. 단위 테스트는 각 단위 기능이 잘 작동하는지 테스트하기 위해 존재한다. 해당 서비스 메서드는 레포지터리 메서드를 감싸는 역할만 수행하기 때문이다. 그래서 사실 이런 경우에는 컨트롤러에서 레포지터리를 직접 호출하는 것도 가능하다.
- 결국 스터빙과 모킹은 테스트가 상세 구현에 의존하게 만든다. '편의성' vs '의존성' 사이의 trade-off를 찾는 것이 중요하다. 가령 레포지터리에서 `findByX`를 호출했을 때 특정 엔티티를 반환하게 하는 동작을 스터빙했다면 추후 해당 동작을 수정하기 어려워진다. DIP(의존 역전 원칙)을 생각해보자. 모킹은 의존성 제거에 도움이 된다. 하지만 모킹으로 인해 수행되어야 하는 스터빙은 끊어진 의존 대상의 구현에 다시 의존하게 만든다.
- (반론) 테스트 주도 개발에서 요구사항을 반영하는 테스트가 먼저 작성되고 그 다음에 구현이 변경된다. 이 경우에는 결국 비즈니스 로직이나 정책을 반영하기 위해서는 테스트 코드를 수정할 수밖에 없다. 즉, '요구사항 변화로 인한 테스트 코드의 변경'은 자연스러운 일이지 않을까? 라는 생각

### 내부 구현을 검증하지 말라 != 과도하게 구현을 검증하지 말라?
비슷한 표현으로 '과도하게 구현을 검증하지 말라'라는 말이 있다. 이 말은 '테스트 주도 개발 시작하기'에서 나왔다. 여기서 핵심은 '과도하게'다. 책의 표현과 향로님 글의 표현은 엄연히 다르다. 왜 향로님 글에서는 '아예 내부 구현을 검증하지 말라' 라는 이야기를 한 것일까?

처음에는 이 말이 굉장히 혼동스러웠다. 아, 그럼 내부 구현을 하지 않고 실제 의존객체들을 주입받아서 써야 하나? 그럼 모킹과 스터빙을 최소화해서 사용해야겠네. 근데 그러면 레이어 간 의존성이 끊어지지 않고 단위 테스트의 의미가 사라지지 않나? 가령 컨트롤러에서 주입받는 서비스 빈을 Mocking & Stubbing 해주지 않으면 컨트롤러의 역할과 책임이 아닌, 서비스의 역할과 책임도 같이 테스트하게 되고 & 스프링 컨텍스트도 같이 로드하게 되므로 단위 테스트가 주는 빠른 테스트의 이점도 사라지게 되지 않나 싶었다.

결론부터 말하자면 '내부 구현을 검증하지 말라'와 '과도하게 구현을 검증하지 말라'는 같은 맥락의 말이다.
이제부터 두 가지 개념을 알아볼 것인데, 하나는 디트로이트 학파 vs 런던 학파 간 단위 테스트 논쟁에 대한 이야기이고, 다른 하나는 블랙박스 테스트와 화이트박스 테스트에 대한 이야기이다. 이 둘을 이해하면 결국 그 말이 그 말이라는 걸 깨닫게 될 것이다.

## 디트로이트 학파 vs 런던 학파 (Classicist vs Mockist)
### 런던 학파
먼저 런던 학파의 방식을 알아보자.

앞서 나는 '모킹과 스터빙을 활용해서 해당 유닛에 대한 모든 의존관계를 끊어내는' 방식으로 '단위' 테스트의 정의를 명확하게 지키려고 했다.
하지만 이렇게 하면 해당 유닛에서 의존하는 다른 모듈의 동작을 스터빙해줘야 하므로, 구현이 노출된다. 구현이 노출되었다는 것은 캡슐화를 지키지 못했다는 것이고, 캡슐화를 지키지 못한 코드는 리팩토링에 매우 취약해진다.

만약 A 모듈에서 B 모듈의 `doB1()`을 호출한다고 하자. 그렇다면 A의 단위 테스트에서 B를 모킹해주고 A에서 사용하는 `doB1()`을 `when(b.doB1()).thenDoSomething()`과 같이 스터빙해줘야 한다.
하지만 이렇게 하게 되면 A의 테스트 코드에서 B의 구현이 노출되게 된다. 만약 B에서 `doB1()`의 동작을 리팩토링했다고 해보자. 그렇다면 `doB1()`을 스터빙한 모든 테스트 코드에서 해당 동작의 input-output이 변경된 동작과 일치하도록 바꿔줘야 한다. 이는 아주아주 귀찮은 일이다.

### 실제 예시
정말로 그런 상황이 있는지 알려주기 위해서 직접 겪었던 예시를 들고왔다.

우리 회사의 경우 인증을 위해서 `@AuthenticationPrincipal`을 사용하여 사용자의 pk값을 가져온 뒤, 유저 레포지터리에서 `findById`로 해당 사용자를 쿼리해오는 방식으로 로그인한 유저를 retrieve하고 있었다.

하지만 로그인이 필요한 대부분의 로직에서 이러한 구조가 반복되고 있어, `SecurityContext`에서 해당 정보를 가져와서 현재 로그인한 유저를 반환하는 `getCurrentUser()` 메서드를 `UserUtils`에 구현했다. 그 다음, 로그인이 필요한 컨트롤러에서는 이 `UserUtils`를 주입받아서 사용했다. (정적 유틸리티가 아닌 스프링 빈으로 관리한 데에는 이유가 있다. 그 부분은 다른 글에서 다룰 것이다)

그리고 모든 문제가 발생했다.

먼저, 모든 서비스의 메서드 시그니쳐가 변경되었다.

기존 구현의 경우 컨트롤러에서 `@AuthenticationPrincipal`을 사용하여 `userId`를 받은 뒤 서비스 코드를 호출할 때 `exampleService.doSomethingByParams(Params params ... , Long userId)`와 같이 마지막 인자로 유저의 pk값을 받은 후, 서비스 코드 내부에서 `userRepository.findById(userId)`와 같이 호출하는 방식으로 현재 유저를 받아왔다.

하지만 이 로직이 전부 제거되었으므로, 모든 서비스 코드에서 `userRepository`에 대한 목 객체를 제거하고, `findById`에 대한 stubbing 역시 전부 제거해줘야 했다. 또, 서비스 테스트에서는 이 stubbing된 메서드가 올바르게 호출되는지 `verify` 해주고 있었기 때문에 이 부분도 통과하도록 수정해줘야 했다. 

이 모든 변화가 **"`userId`를 인자로 받는 모든 서비스 테스트 코드에"** 대해서 발생했다. 얼마나 지옥같았는지 상상이 가는가?

### 런던 학파 (Mockist)





### 블랙박스와 화이트박스
- 모킹은 블랙박스 영역이 다른 모듈의 화이트박스 영역으로 전파되지 않도록 격리하는 역할을 한다. 이때, 인터페이스에 기반한 스터빙을 사용하여 input-output을 정의한다.

### 서비스 레이어 유닛 테스트 전략
- 레포지터리 메서드의 경우 이미 검증했으므로 실제 저장 및 조회는 stubbing


### 테스트 코드 최적화
- 빠른 테스트는 중요하다.
- 테스트 케이스와 테스트 시간은 선형적이라기보다는 지수적이다.
- 아래와 같이 최적화할 수 있다.
    - 테스트 시간을 줄인다. 스프링 로드를 최소화한다.
    - 공통된 로직을 제거한다.
    - 테스트 전용 인스턴스인 픽스쳐 생성 방식을 통일한다.
https://bperhaps.tistory.com/entry/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%97%AC%ED%96%89%EA%B8%B0-1


## 레퍼런스
https://jojoldu.tistory.com/614
https://jojoldu.tistory.com/637
https://www.inflearn.com/questions/152501/service-layer-test%EC%99%80-service-layer-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8%EC%9E%85%EB%8B%88%EB%8B%A4
https://stackoverflow.com/questions/12539365/when-to-use-mockito-verify
https://tech.kakaopay.com/post/mock-test-code/
https://tech.kakaopay.com/post/mock-test-code-part-2
https://tjdtls690.github.io/studycontents/java/2023-05-08-spring_unit_test/
https://www.inflearn.com/questions/870708/%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B3%84%EC%B8%B5%EC%9D%98-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B2%94%EC%9C%84%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C (이 강의도 듣고싶다...)
https://stackoverflow.com/questions/12539365/when-to-use-mockito-verify (모킹과 블랙박스 / 화이트박스에 대한 글)