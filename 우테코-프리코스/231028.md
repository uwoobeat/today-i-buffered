# 우테코 2주차 설계

## 입출력 모듈 설계

저번 글에서도 고민이 많았던 것이 "입출력 로직"을 어떻게 분리할 것이냐다. 그건 입출력이 언제 필요하냐에 따라 달라진다고 했다. 저번에는 `입력 모듈 -> (입력 요청 메세지) -> 한 가지 일만 하기 -> (출력 요청 메세지) -> 출력 모듈` 이라고 했는데, 조금 더 엄밀하게 고쳐보자면 `입력/출력 모듈 -> (입력/출력 요청 메세지) -> 여러 가지의 일들 -> 입력/출력 모듈` 이 맞다.

입출력이 하나의 기준이 될 수 있는 것은 맞지만 유일한 기준이어야 하는 것은 아니다. 입출력 세계에서 객체지향 세계로 들어가고 나서도, 한 가지 일의 기준이 존재할 수 있다. 가령 경주 플레이와 자동차 간의 통신 역시 기준이 될 수 있다. 단, 절대 어기지 말아야 하는 조건이란 이 정도가 있겠다.

### 하나의 입출력부터, 다음 입출력까지 최소 하나의 작업 단위가 완료되어야 한다. 

여러 개의 작업을 수행하는 것은 상관없다. 만약 A라는 입출력 작업이 있고, 그 다음에는 B라는 입출력 작업이 필요하다고 하자. A 작업이 입력이라면 그 결과로 어떤 가공된 결과를 내려줄 것이고, 출력이라면 이전 내부 작업의 결과를 받아서 출력할 것이다. 만약 A 작업이 내려준 결과로 "특정 작업"들을 수행하고, 그 작업 결과를 B 작업에서 출력해야 한다고 하자. 근데 "특정 작업"들이 하나의 메서드에 있다면? 즉, 하나의 메서드가 여러 가지 일을 한다면 어떻게 될까? 헉 그러면 입출력을 못하는 건가요?

아니다. 그래도 할 수 있다. 그런데 그렇게 하면 캡슐화가 깨지게 된다. "특정 작업"이 어떤 클래스의 private 메서드 x() -> y() -> z() 순서로 한다고 하자. x는 적절한 인풋을 받아서 처리하고 y도 그걸 받아서처리하고 z도 처리한 다음에 외부로 public 메서드를 통해 최종 결과를 반환하게 된다. 

근데 적절한 역할로 쪼개지지 않은 (즉 하나의 클래스에서) 클래스라서 y의 결과물을 출력해줘야 한다면 y는 private 메서드이기 때문에, y의 마지막 혹은 z의 앞단에서 출력 모듈을 호출해야 한다. 그러면 이 클래스는 출력 모듈을 "알게 된다".

우리가 입출력 기능을 분리하겠다는 것은 무슨 의미인가? 게임 클래스, 플레이어 클래스, 게임넘버 클래스가 "입출력 모듈을 모르게"- 즉 해당 모듈의 메서드를 호출하지 않게 하고, 입출력 모듈에서 해당 클래스의 인스턴스에 대하여 getter를 호출하여 알아서 처리하도록 만들겠다는 뜻이다.

캡슐화 대해서 내가 좋아하는 비유가 있다. 의사가 "환자분 약 먹으니 상태가 좀 어떠세요" 하고 물어보면 환자가 "아 확실히 속이 좀 진정되는 것 같아요" 하고 답변하면 되는 것을, 의사가 환자가 채 답변하기 전에 환자의 배를 가르고 내부 장기 상태를 직접 체크하는 잔인한 짓을 저지르는 것이 바로 캡슐화 위반이라는 것이다.

### 입력 모듈과 출력 모듈의 차이는?

출력 모듈의 경우, 객체로부터 메세지를 전달받아서 "적절한 형태로 가공"하여 출력하는 역할을 한다. 만약 자동차의 이름이 "소나타" 라면, "현재 차 이름 : 소나타" 와 같이 적절한 출력 포맷을 지정해주는 역할이라고 할 수 있다.

출력 모듈은 그 역할이 꽤나 자명하다. 입력 모듈에서 헷갈리는 점이 상당히 많다.

입력 모듈의 경우, 사용자로부터 입력값을 전달받아서 "적절한 형태로 파싱"하여 전달하는 역할을 한다. 이때, 적절하 형태란 객체의 인터페이스에 따라 좌우된다. 만약 자동차를 생성할 때 인자로 이름을 받는다고 하자. 그러면 `new Car("이름");` 과 같이 생성할 것이다. 이때 사용자 입력이 `이름1, 이름2, 이름3` 과 같이 주어졌다면, 자동차를 생성하는 코드는 `new Car("이름1");`, `new Car("이름2");`, `new Car("이름3");` 과 같이 여러 번 호출되어야 한다.

만약에 `CarFactory` 라는 클래스가 있고, 여기서는 `List<String> carNames = Arrays.asList("이름1", "이름2", "이름3");` 과 같은 인자를 받는다고 하자. 그러면 입력 모듈은 `이름1, 이름2, 이름3` 과 같은 입력을 받아서 `List<String>` 으로 파싱해야 한다.

하고 싶은 말이 뭐냐? 내부 인터페이스가 어떤 형태로 인자를 받느냐에 따라 입력 모듈의 역할이 조금조금씩 달라진다는 거다. 그래서 입력 모듈은 "적절한 형태로 파싱"하는 역할을 한다고 했다. 적절한 형태란, 내부 인터페이스에 따라 달라진다.

### 어디서 호출하고 어디서 받을 것인가

누군가는 입력 모듈을 호출해야 한다. 누군가는 출력 모듈을 호출해야 한다. 입력 모듈로 하여금 사용자로부터 입력을 파싱하여 전달받게 만들고 싶다면, 누군가는 "입력이 필요한 상황을 인지하고(생성자나 setter, 혹은 그 외 메서드의 invocation 이후), 입력 모듈을 호출해서, 이 값을 필요로 하는 요청자에게 전달해야" 한다. 또, 출력 모듈로 하여금 어떠한 작업의 결과를 메세지로 전달받아서 적절한 형태로 가공하여 출력하게 만들고 싶다면, 누군가는 "출력이 필요한 상황을 인지하고(어떠한 함수의 return, 혹은 그 외 메서드의 invocation 이후), 출력 모듈을 호출해서, 이 값을 필요로 하는 요청자에게 전달해야" 한다.

기존에는 어땠을까? 필요한 객체가 입력을 받아왔다. 특히 입력 모듈이 필요하지 않았던 이유이기도 한데, "하나의 입력은 하나의 요청으로만 매핑되었다". 지금은 "하나의 입력이 여러 요청으로 나뉘어야 한다". 특히 자동차 이름이 한 번에 여러 개 주어졌을 때, 입력 모듈에서 이걸 잘 조율해주지 않는다면, 이전처럼 플레이어가 직접 콘솔 입력을 읽어오는 것은 불가능할 것이다. 출력의 경우 "그 상태를 가지고 있는 객체가" 직접 출력하는 책임을 가졌다.


### 모두가 입출력 모듈에 의존할 수는 없으니까

하지만 지금은 입출력 모듈 의존성을 어딘가에서 덤탱이쓰고, 다른 친구들은 입출력 모듈 자체를 모른 채 이 덤탱이 쓴 클래스를 통해 외부 값을 전달받고 출력을 요청한다. 엄밀하게는 출력을 요청하지 않고, 객체의 상태나 객체만 전달받는다. 


### 입출력을 정적 유틸리티 메서드로 관리하는 것이 옳은 것인가?

정적 유틸리티 클래스에 대한 논쟁은 다양하다. 이게 옳은지 나쁜지에 대해서 논쟁하려면 수만, 수십만 줄의 사례들과 반박 그리고 케이스 스터디가 필요할 것이다. 그러니 현재 케이스에만 초점을 맞추자. 사실 여러 레퍼런스를 보면서 공부를 했지만 그 과정을 적기에는 너무 글이 길어지기에 결론만 간략하게 적는다. 최종적으로, 정적 유틸리티에 대한 내 생각은 이렇다.

1. 상태를 가지고 있다면 정적 유틸리티 클래스는 사용하지 않는다.
2. 상태를 가지고 있지 않지만, 전방위적으로 사용된다면 정적 유틸리티 클래스는 사용하지 않는다.
3. 서로 다른 컨텍스트에서 호출되어야 한다면 정적 유틸리티 클래스는 사용하지 않는다.
3. DI 컨테이너를 사용할 수 있다면 정적 유틸리티 대신 싱글톤 인스턴스 클래스를 사용한다.

입출력의 경우 상태를 가지지 않는다. 일종의 배치 잡같은 느낌이다. 뭔가를 받아서 -> 적절히 가공해서 -> 던져주거나 출력한다. 하지만 입출력은 전방위적으로 사용된다. 사실 정적 유틸리티를 쓰면 변화에 유연하게 대응하기 어려워지는 것은 맞다. 하지만 작게작게 사용한다면 그 변화를 리팩토링하는 것은 감당할만하다. 하지만 시스템 전체에서 몇 천번 이상 사용되는 `FileUtils` 클래스를 감당할 수 있겠는가?

2번을 보고 "아 이 정적 유틸리티는 상태를 가지고 있지 않으니까 괜찮겠다" 라고 생각할 수도 있다. 그런 경우를 위해서 3번을 넣었다. 만약 이 유틸을 호출하는 컨텍스트가 굉장히 가변적이라고 하자. 그 말은 즉슨 나중에 요구사항 변경이 발생할 수도 있다는 것이다. 가령... "어... 생각해보니까 상태를 넣는게 나을지도? ㅎㅎ ㅈㅅ ㅋㅋ" 같이 말이다. 정적 유틸리티는 상태를 가질 수 없으므로 싱글톤의 인스턴스 메서드로 변경해줘야 하고, 기존에 정적 유틸리티를 사용하는 모든 곳에서 지옥같은 변경이 발생하게 된다.

헉 그걸 어떻게 아셨나요? 저도 알고 싶지 않았습니다...


### 입력 모듈이 생겼을 때 검증 책임은?

원래는 매핑해오는 객체 쪽에서 입력 모듈을 직접 호출하기 때문에 객체 쪽에서 유저가 입력한 값에 대한 책임을 모두 떠앉는다. 하지만 지금은 입력 모듈을 한번 거치기 때문에 참 애매한 감이 있다.

고민해본 결과 "포맷에 대한 파싱"은 입력 모듈이 책임지고, "올바르게 파싱된 값의 유효성"은 객체에서 책임지는 것이 맞는 것 같다. 가령 "0,1a,2,3," 이라는 인풋에 대하여, 숫자로 파싱되지 않는 1a의 경우 입력 모듈에서 예외를 터트리는 것이 맞다. 하지만 만약 이 0, 2, 3이라는 값으로 UID를 만든다고 할 때 0은 허용하지 않는다는 규칙이 있다면 객체 생성자에서 인풋이 0인 것에 대한 예외를 터트리게 된다.

요약하자면 "신택스 에러" -> "입력 모듈", "시맨틱 에러" -> "객체 클래스"가 책임진다.

## 기능 명세 간단하게

### 게임 매니저

### 입력 매니저
- 

### 출력 매니저

### 게임
- 게임은 게임에 참여하는 자동차들을 가진다.
- 게임은 이동 시도횟수를 가진다.
- 게임은 이동 시도횟수만큼 자동차에게 전진 요청을 한다.

### 자동차

- 자동차는 이름을 가진다.
- 자동차는 전진 가능여부를 가진다.
- 자동차는 전진 요청을 받으면 전진 가능여부에 따라 전진하거나 정지한다.
